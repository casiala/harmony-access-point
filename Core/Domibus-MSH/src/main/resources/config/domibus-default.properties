# ---------------------------------- Cluster -----------------------------------

#Specifies if Domibus should run in cluster mode. This affects for instance whether the Quartz jobs are clustered.
domibus.deployment.clustered=false

#In cluster mode, specifies if the database synchronization mechanism should be used when initializing the Quartz scheduler
domibus.scheduler.bootstrap.synchronized=true

#Timeout for the database synchronization mechanism, in milliseconds
domibus.synchronization.timeout=10000

# ---------------------------------- GUI -------------------------

# The title shown in the Tab of Admin Console (default value: "Domibus")
domibus.ui.title.name=Harmony AP

#support team name
domibus.ui.support.team.name=Nordic Institute for Interoperability Solutions (NIIS)

#support team email
domibus.ui.support.team.email=edelivery@niis.org

#Max rows for CSV export
domibus.ui.csv.rows.max=10000

# how many minutes after message's received date the Resend button will become enabled for messages having SEND_ENQUEUED status
domibus.ui.resend.action.enabled.received.minutes=5

#The limit when calculating the number of message logs(disabled when 0)
domibus.ui.pages.messageLogs.countLimit=50000

#The initial/default interval (in hours) for filtering messages
domibus.ui.pages.messageLogs.interval.default=24

#Whether the Messages page should be the default landing page after login (defaults to true, but should be set to false in high load environments)
domibus.ui.pages.messageLogs.landingPage.enabled=true

#Whether the Messages page has all the advanced capabilities (defaults to true, but should be set to false in high load environments)
domibus.ui.pages.messageLogs.search.advanced.enabled=true

#Used to secure the session of admin console; set to true only in conjunction with https protocol
domibus.ui.session.secure=false

#Used to set the the session timeout of admin console ( in minutes )
domibus.ui.session.timeout=30

#Used to set the SameSite attribute of cookies (session and all others) used by the admin console. Possible values are: Strict, None, Lax
domibus.ui.session.sameSite=Strict

# ---------------------------------- EntityManagerFactory ----------------------

#Packages to be scanned(comma separated)
domibus.entityManagerFactory.packagesToScan=eu.domibus

domibus.entityManagerFactory.jpaProperty.hibernate.format_sql=true

#Batch size for hibernate update and insert (Best practice is to keep this value <100)
domibus.entityManagerFactory.jpaProperty.hibernate.jdbc.batch_size=30

domibus.entityManagerFactory.jpaProperty.hibernate.order_inserts=true
domibus.entityManagerFactory.jpaProperty.hibernate.order_updates=true

domibus.entityManagerFactory.jpaProperty.hibernate.connection.provider_disables_autocommit=true

domibus.entityManagerFactory.jpaProperty.hibernate.cache.use_query_cache=true
domibus.entityManagerFactory.jpaProperty.hibernate.cache.use_second_level_cache=true
domibus.entityManagerFactory.jpaProperty.hibernate.cache.region.factory_class=infinispan
domibus.entityManagerFactory.jpaProperty.hibernate.cache.infinispan.cfg=config/infinispan/domibus-infinispan-default.xml
domibus.entityManagerFactory.jpaProperty.hibernate.cache.keys_factory=eu.domibus.core.cache.DomibusCacheKeysFactory
domibus.entityManagerFactory.jpaProperty.hibernate.cache.generate_statistics=false
domibus.entityManagerFactory.jpaProperty.hibernate.cache.default_cache_concurrency_strategy=read-only
domibus.entityManagerFactory.jpaProperty.hibernate.javax.cache.missing_cache_strategy=create

# ---------------------------------- Security ----------------------------------

#Domibus encrypts the configured passwords if activated
domibus.password.encryption.active=false

#The location where the encrypted key is stored
domibus.password.encryption.key.location=${domibus.config.location}/internal/encrypt

#To activate security set this to false
domibus.auth.unsecureLoginAllowed=true

#Number of console login attempt before the user is deactivated (default 5)
domibus.console.login.maximum.attempt=5

#Time in seconds for a suspended user to be reactivated. (1 hour per default if property is not set, if 0 the user will not be reactivated)
domibus.console.login.suspension.time=3600

#Cron job that determines the interval at which the system checks for account to be reactivated.
domibus.account.unlock.cron=0 0/1 * * * ?

#When a certificate is about to expires the system will log a warning. The warning will appear as from the expiration date - the offset in days.
domibus.certificate.revocation.offset=15

#Cron expression that specifies the frequency of the certificate revocation check.
domibus.certificate.check.cron=0 0 0/1 * * ?

#Must be set on true if there is an external authentication provider. Defaults to false.
domibus.security.ext.auth.provider.enabled=false

#Position of the Bouncy Castle in the security providers list; Performance will decrease if the Bouncy Castle provider is moved downward in the list
domibus.security.provider.bouncyCastle.position=3

#Configure http timeout (http.connection.timeout, http.socket.timeout, http.connection-manager.timeout) in seconds. Defaults to 10 seconds.
domibus.certificate.crl.http.timeout=10

#Enable caching of CRLs by URL. To enable, also uncomment the cache in the ehcache xml configuration
# If crlByCert cache is not enabled or if it doesn't contain the key for a certificate then this cache is used
domibus.certificate.crlByUrl.cache.enabled=false

#Enable caching of CRLs by certificate. Note that, while a CRL is cached, any certificates that were revoked since it was cached would still be accepted
domibus.certificate.crlByCert.cache.enabled=true

# ---------------------------------- Extensions ----------------------------------
#Name of the authentication extension used to verify the chain trust. Default is CXF
domibus.extension.iam.authentication.identifier=DEFAULT_AUTHENTICATION_SPI
#Name of the authorization extension used to check incoming message authorization. Default is truststore check.
domibus.extension.iam.authorization.identifier=DEFAULT_AUTHORIZATION_SPI

# ---------------------------------- Plugin Security ----------------------------------

#Number of plugin users login attempts before the user is deactivated (default 5)
domibus.plugin.login.maximum.attempt=5

#Time in seconds for a suspended plugin user to be reactivated. (1 hour per default if property is not set, if 0 the user will not be reactivated)
domibus.plugin.login.suspension.time=3600

#Cron job that determines the interval at which the system checks for plugin account to be reactivated.
domibus.plugin.account.unlock.cron=0 0/1 * * * ?

# ---------------------------------- Payload -----------------------------------

# Sets businessContentAttachment enabled in payload
domibus.payload.business.content.attachment.enabled=false

#Domibus encrypts the payloads stored in the database or file system if this property is active.
domibus.payload.encryption.active=false

#Cron expression that specifies the frequency of checking if the temporary payloads have expired
domibus.payload.temp.job.retention.cron=0 0/10 * * * ?

#The threshold in minutes for considering the temporary payloads as expired. The expired temporary payloads are scheduled to be deleted.
domibus.payload.temp.job.retention.expiration=120

#Temporary files are excluded from deletion if this regular expression matches the file name
domibus.payload.temp.job.retention.exclude.regex=.*ehcache-sizeof-agent.*

#List of directories to check for cleaning the temporary files.
domibus.payload.temp.job.retention.directories=domibus.attachment.temp.storage.location

#Limit attachments per message to 28 (count enforced by Apache Santuario library for extended XML signature validation. Ref: https://santuario.apache.org/faq.html#faq-4.SecureValidation)
domibus.payload.limit.28attachments.per.message=true

#When set to true, Domibus tries to decompress the archived payloads on receiving a message. In case it fails to decompress one payload, an error receipt is returned. Defaults to false.
domibus.payload.decompression.validation.active=false

# ---------------------------------- Message -----------------------------------

#The suffix of the messageId generated by this instance of domibus. Schema is:  ${UUID}@${SUFFIX}
domibus.msh.messageid.suffix=edelivery.digital

#The maximum size of message in bytes that can be downloaded via admin console
domibus.message.download.maxSize=10000000

#Message resend job execution interval as a cron expression
domibus.message.resend.cron = 0 0/1 * * * ?

#Activates the plugin notification of Test messages
domibus.message.test.notification=false

# ---------------------------------- Retry -------------------------------------

#Retry Worker execution interval as a cron expression
domibus.msh.retry.cron=0/30 * * * * ?

#Retry strategy grants few extra seconds to avoid not sending the last attempt (value in milliseconds, default 30000)
domibus.msh.retry.messageExpirationDelay=30000

#Retry strategy adds these extra minutes to the interval used to search back for messages in WAITING_FOR_RETRY status. For performance reasons, the interval defaults to 10 minutes.
#When there are older messages in WAITING_FOR_RETRY (e.g. restored messages), increase the interval to capture those messages as well.
domibus.msh.retry.timeoutDelay=10

#List of party names for which the smart retry feature is active (comma-separated list)
domibus.smart.retry.enabled=

# ---------------------------------- Dynamic Discovery -------------------------

#Whether to use dynamic discovery or not
domibus.dynamicdiscovery.useDynamicDiscovery=false

#The SML zone
domibus.smlzone=acc.edelivery.tech.ec.europa.eu

#The dynamic discovery client to be used for the dynamic process. Possible values: OASIS and PEPPOL. Defaults to OASIS.
domibus.dynamicdiscovery.client.specification=OASIS

# List of certificate policy OIDs separated by comma where at least one must be in the service metadata signer's
# certificate policy extension to consider it as is trusted. Example: 1.3.6.1.4.1.7879.13.25
# (empty value disables the certificate policy validation)
domibus.dynamicdiscovery.client.allowedCertificatePolicyOIDs=

#The role of the responder PartyId for the Peppol Dynamic Discovery Client
domibus.dynamicdiscovery.peppolclient.partyid.responder.role=urn:fdc:peppol.eu:2017:roles:ap:as4

#The role of the responder PartyId for the Oasis Dynamic Discovery Client
domibus.dynamicdiscovery.oasisclient.partyid.responder.role=http://docs.oasis-open.org/ebxml-msg/ebms/v3.0/ns/core/200704/responder

#The type of the PartyId for the Peppol Dynamic Discovery Client
domibus.dynamicdiscovery.peppolclient.partyid.type=urn:fdc:peppol.eu:2017:identifiers:ap

#The type of the PartyId for the Oasis Dynamic Discovery Client
domibus.dynamicdiscovery.oasisclient.partyid.type=urn:oasis:names:tc:ebcore:partyid-type:unregistered

#The AS4 transport profile by which the endpoint is identified in the SMP response
domibus.dynamicdiscovery.transportprofileas4=bdxr-transport-ebms3-as4-v1p0

#The lookup types used by the dynamic discovery client
domibus.dynamicdiscovery.client.dns.lookup.types=NAPTR,CNAME

#Retention cron expression for the job responsible for deleting from the truststore the dynamically discovered certificates and from the Pmode dynamically discovered parties
#It executes at 23:00 every Saturday
domibus.dynamicdiscovery.lookup.clean.retention.cron=0 0 23 ? * SAT *

#Retention in hours for deleting the following entities:
# - from the truststore the dynamically discovered certificates
# - from the Pmode the dynamically discovered parties
# - final recipient endpoint URL
#Entities will be deleted if they are not lookup up during the configured value
#If the property value is empty, the entities will not be deleted
domibus.dynamicdiscovery.lookup.clean.retention.hours=48

#Global cache property for dynamic discovery lookup caching in seconds
domibus.dynamicdiscovery.lookup.cache.ttl=3600

# ---------------------------------- Dispatcher --------------------------------

#Timeout values for communication between the Access Points
#ConnectionTimeOut - Specifies the amount of time, in milliseconds, that the consumer will attempt to establish a connection before it times out. 0 is infinite.
domibus.dispatcher.connectionTimeout=60000

#ReceiveTimeout - Specifies the amount of time, in milliseconds, that the consumer will wait for a response before it times out. 0 is infinite.
domibus.dispatcher.receiveTimeout=60000

#Allows chunking when sending messages to other Access Points
domibus.dispatcher.allowChunking=false

#If domibus.dispatcher.allowChunking is true, this property sets the threshold at which messages start getting chunked(in bytes). Messages under this limit do not get chunked. Defaults to 100 MB.
domibus.dispatcher.chunkingThreshold=104857600

#Specify concurrency limits via a "lower-upper" String, e.g. "5-10", or a simple upper limit String, e.g. "10" (the lower limit will be 1 in this case)
#when sending messages to other Access Points
domibus.dispatcher.concurency=5-20

#The timeout of the dispatcher JMS queue transaction(in seconds)
domibus.dispatcher.timeout=300

#Specify concurrency limits via a "lower-upper" String, e.g. "5-10", or a simple upper limit String, e.g. "10" (the lower limit will be 1 in this case)
#when sending large messages(SplitAndJoin) to other Access Points
domibus.dispatcher.largeFiles.concurrency=1

#Cache the dispatcher clients used for communication between the Access Points. Defaults to true.
domibus.dispatcher.cacheable=true

#Specifies if the connection will be kept alive between C2 and C3. Default value is true.
domibus.dispatcher.connection.keepAlive=true

# ---------------------------------- Retention ---------------------------------

#Cron expression used for configuring the retention worker scheduling. The retention worker deletes the expired messages(downloaded and not-downloaded).
domibus.retentionWorker.cronExpression=0 0/1 * * * ?

#Maximum downloaded messages to be deleted by the retention worker.
domibus.retentionWorker.message.retention.downloaded.max.delete=50

#Maximum not-downloaded messages to be deleted by the retention worker.
domibus.retentionWorker.message.retention.not_downloaded.max.delete=50

#Maximum sent messages to be deleted by the retention worker.
domibus.retentionWorker.message.retention.sent.max.delete=50

#Uncomment the following line if you need to tweak the maximum messages with payload deleted to be fully deleted by the retention worker. Defaults to 50.
domibus.retentionWorker.message.retention.payload_deleted.max.delete=50

#Define the deletion strategy. Possible values are: DEFAULT, PARTITIONS (Oracle only)
domibus.retentionWorker.deletion.strategy=DEFAULT

### Configure next properties depending on the selected deletion strategy
### ---------------------------------- Retention - Deletion Strategy DEFAULT ---------------------------------

#Maximum number of messages to be deleted by the retention worker in a bulk delete (when not specified in the PMode MPC). Defaults to 1000, maximum allowed when using Oracle database.
domibus.retentionWorker.message.retention.batch.delete=1000

#Specify concurrency limits via a "lower-upper" String, e.g. "5-10", or a simple upper limit String, e.g. "10" (the lower limit will be 1 in this case)
#when deleting messages
domibus.retention.jms.concurrency=5-10

### ---------------------------------- Retention - Deletion Strategy PARTITIONS ---------------------------------
#Cron expression used for configuring the partition worker scheduling. The partition worker verifies if partitions were properly created in advance
domibus.partitions.worker.cron=0 9 * * * ?

#Number of days to check if partitions were successfully created in advance. Defaults to 7 days.
domibus.partitions.creation.days_to_check=7

#When set to true, before dropping a partition, verifies if all messages on that partition were previously archived.
#This check is a guard rail for dropping partitions when the eArchiving mechanism is disabled. Default is true.
domibus.partitions.drop.check.messages.earchived=true

#Cron expression used to configure the sanitizer worker that targets messages not in a final state that are not processed anymore
domibus.ongoingMessagesSanitizing.worker.cron=0 0 0/2 ? * * *

# ---------------------------------- Proxy -------------------------------------

domibus.proxy.enabled=false
domibus.proxy.http.host=
domibus.proxy.http.port=
domibus.proxy.user=
domibus.proxy.password=
domibus.proxy.nonProxyHosts=

# ---------------------------------- Alert management -----------------------------------

#Cron configuration for cleaning alerts.
domibus.alert.cleaner.cron=0 0 0/1 * * ?

#Lifetime in days of alerts before cleaning.
domibus.alert.cleaner.alert.lifetime=20

#Enable/disable the entire alert module.
domibus.alert.active=true

#Allow to disable alert mail sending.
domibus.alert.mail.sending.active=false

#SMTP Socket I/O timeout value in milliseconds
domibus.alert.mail.smtp.timeout=5000

#Concurrency to process the alerts.
domibus.alert.queue.concurrency=1

#Frequency of failed alerts retry.
domibus.alert.retry.cron=0 0/10 * * * ?

#Elapsed time in minutes between alert retry.
domibus.alert.retry.time=10

#Maximum number of attempts for failed alerts
domibus.alert.retry.max_attempts=2

# ---------------------------------- Alert management:messaging module -----------------

#Enable/disable the messaging alert module.
domibus.alert.msg.communication_failure.active=true

#Message status change that should be notified by the messaging alert module. Comma separated.
domibus.alert.msg.communication_failure.states=SEND_FAILURE

#Alert levels corresponding to message status defined in previous property(domibus.alert.msg.communication_failure.states) .
#Should be (HIGH, MEDIUM OR LOW)
domibus.alert.msg.communication_failure.level=HIGH

#Messaging alert module mail subject.
domibus.alert.msg.communication_failure.mail.subject=Message status change

#The priority level of the alerts that report the messages in a non-final state that are not processed anymore (LOW, MEDIUM or HIGH)
domibus.ongoingMessagesSanitizing.alert.level=MEDIUM

#Subject of the email alerts that report the messages in a non-final state that are not processed anymore
domibus.ongoingMessagesSanitizing.alert.email.subject=Ongoing messages

#Body of the email alerts that report the messages in a non-final state that are not processed anymore
domibus.ongoingMessagesSanitizing.alert.email.body=There are messages currently in ongoing statuses that are not processed anymore. Here is the list of IDs and statuses of these messages: [{messages}].

# ---------------------------------- Alert management:Authentication module -----------------

#Enable/disable the login failure alert of the authentication module.
domibus.alert.user.login_failure.active=true

#Alert level for login failure.
domibus.alert.user.login_failure.level=LOW

#Login failure mail subject.
domibus.alert.user.login_failure.mail.subject=Login failure

#Enable/disable the account disable alert of the authentication module.
domibus.alert.user.account_disabled.active=true

#Alert level for account disabled. Used in the email to be sent. Values: {LOW, MEDIUM, HIGH}
domibus.alert.user.account_disabled.level=HIGH

#When should the account disabled alert be triggered.
# 2 possible values:
# AT_LOGON: An alert will be triggered each a time user tries to login to a disabled account.
# WHEN_BLOCKED: An alert will be triggered once when the account got disabled.
domibus.alert.user.account_disabled.moment=WHEN_BLOCKED

#Account disabled mail subject.
domibus.alert.user.account_disabled.subject=Account disabled

#Enable/disable the account enabled alert of the authentication module.
domibus.alert.user.account_enabled.active=false

#Alert level for account enabled. Used in the email to be sent. Values: {LOW, MEDIUM, HIGH}
domibus.alert.user.account_enabled.level=MEDIUM

#Account enabled mail subject.
domibus.alert.user.account_enabled.subject=Account enabled

# ---------------------------------- Alert management:Certificate scanner -----------------

#Enable/disable the imminent certificate expiration alert of certificate scanner module.
domibus.alert.cert.imminent_expiration.active=true

#Number of days before revocation as from when the system should start sending alerts.
domibus.alert.cert.imminent_expiration.delay_days=60

#Frequency in days between alerts.
domibus.alert.cert.imminent_expiration.frequency_days=14

#Certificate imminent expiration alert level.
domibus.alert.cert.imminent_expiration.level=HIGH

#Certificate imminent expiration mail subject.
domibus.alert.cert.imminent_expiration.mail.subject=Certificate imminent expiration

#Enable/disable the certificate expired alert of certificate scanner module.
domibus.alert.cert.expired.active=true

#Frequency in days between alerts.
domibus.alert.cert.expired.frequency_days=7

#How long(in days) after the revocation should the system trigger alert for the expired certificate.
domibus.alert.cert.expired.duration_days=90

#Certificate expired alert level.
domibus.alert.cert.expired.level=HIGH

#Certificate expired mail subject.
domibus.alert.cert.expired.mail.subject=Certificate expired

# ---------------------------------- Alert management: Partitions -----------------
#Frequency in days between alerts.
domibus.alert.partition.check.frequency_days=1

# ---------------------------------- Alert management: E-Archiving Module -----------------

#Enable/disable the EArchiving notification failed alerts.
domibus.alert.earchive.notification.active=true

#EArchiving notification failed alert level.
domibus.alert.earchive.notification.level=MEDIUM

#EArchiving notification failed mail subject.
domibus.alert.earchive.notification.mail.subject=E-Archiving client notification failed

# ---------------------------------- Alert management: Connection Monitoring -----------------
#Comma separated list of parties for whom to create alerts
domibus.alert.connection.monitoring.parties=ALL

#Connection monitoring failed alert frequency in days.
domibus.alert.connection.monitoring.frequency_days=1

#Connection monitoring failed alert level.
domibus.alert.connection.monitoring.level=MEDIUM

#Connection monitoring failed mail subject.
domibus.alert.connection.monitoring.mail.subject=Connection monitoring failed

# ---------------------------------- Pulling-----------------------------------

#Cron expression used for configuring the message puller scheduling.
domibus.msh.pull.cron=0 0 0/1 * * ?

# Number of threads used to parallelize the pull requests.
domibus.pull.queue.concurency=1-1

# Number of threads used to parallelize the pull receipts.
domibus.pull.receipt.queue.concurrency=5-20

#Number or requests executed every cron cycle
domibus.pull.request.send.per.job.cycle=1

#Time in second for the system to recover its full pull capacity when job schedule is one execution per second.
#If configured to 0, no incremental frequency is executed and the pull pace is executed at its maximum.
domibus.pull.request.frequency.recovery.time=0

#Number of connection failure before the system decrease the pull pace.
domibus.pull.request.frequency.error.count=10

#Pull Retry Worker execution interval as a cron expression
domibus.pull.retry.cron=0/10 * * * * ?

#Allow dynamic initiator on pull requests - 0 or multiple initiators are allowed in the Pmode process
domibus.pull.dynamic.initiator=false

#Allow multiple legs configured on the same pull process (with the same security policy)
domibus.pull.multiple_legs=false

#Force message into READY_TO_PULL when mpc attribute is present
domibus.pull.force_by_mpc=false

#MPC initiator separator. This is used when the MPC provides information on the initiator.
domibus.pull.mpc_initiator_separator=PID

# ---------------------------------- JMS ---------------------------------------

#Domibus internal queue used for dispatching the pull requests
domibus.jms.queue.pull=jms/domibus.internal.pull.queue

#The maximum number of pending messages to be listed from the backend notification queue. Setting this property is expected to avoid timeouts due to huge result sets being served.
#Setting this property to zero returns all pending messages
domibus.listPendingMessages.maxCount=500

#The maximum number of messages to be listed from the JMS queues. Setting this property is expected to avoid timeouts due to huge results being served.
#Setting this property to zero returns all messages
domibus.jms.queue.maxBrowseSize=10000

#Domibus internal queue used for alerts
domibus.jms.queue.alert=jms/domibus.internal.alert.queue

#Concurrency configured for executing internal commands
domibus.jms.internal.command.concurrency=1-1

#The desired size for the JMS Session cache
domibus.jms.connectionFactory.session.cache.size=1

# ---------------------------------- Validation --------------------------------

#If activated, Domibus will check if the received message is self sent
domibus.receiver.selfsending.validation.active=true

#If activated Domibus will verify before sending a message if the receiver's certificate is valid and not revoked. If the receiver's certificate
#is not valid or it has been revoked Domibus will not send the message and it will mark it as SEND_FAILURE (default is true)
domibus.receiver.certificate.validation.onsending=true

#If activated Domibus will verify before sending a message if his own certificate is valid and not revoked. If the certificate is not valid
#or it has been revoked Domibus will not send the message and it will mark it as SEND_FAILURE (default is true)
domibus.sender.certificate.validation.onsending=true

#If activated Domibus will verify before receiving a message if the sender's certificate is valid and not revoked. If the certificate is
#not valid or it has been revoked Domibus will not accept the message (default is true)
domibus.sender.certificate.validation.onreceiving=true

#If activated Domibus will verify before receiving a message, the validity and authorization on the sender's certificate. When disabled,
#none of the other checks are performed on the sender's certificate.
domibus.sender.trust.validation.onreceiving=true

#When this property is not empty Domibus will verify before receiving a message, that the subject of the sender's certificate matches the regular expression.
domibus.sender.trust.validation.expression=

# List of certificate policy OIDs separated by comma. When this property is not empty Domibus will verify before receiving a message,
# that certificate contains at lest one certificate policy OID in certificatePolicy extension to consider it as is trusted.
domibus.sender.trust.validation.allowedCertificatePolicyOIDs=

#When enabled, Domibus will verify before receiving a message, that the alias (party name) is present in the signing certificate subject.
domibus.sender.certificate.subject.check=false

#When enabled, Domibus will verify before receiving a message, that the sender's certificate matches the certificate in the truststore,
#loaded based on the alias (party name)
domibus.sender.trust.validation.truststore_alias=true

#When enabled, the system default certificates (cacerts) are used in addition to custom certificates, to validate that a call to a https server can be trusted
domibus.cacerts.validation.enabled=true

#Accepted Format for MessageId (Default value, based on RFC2822 [CORE 5.2.2.1]: ^[\\x20-\\x7E]*$ ): all characters in hexa interval 20-7E but '=' character)
domibus.sendMessage.messageIdPattern=^(?!.*[=])[\\x20-\\x7E]*$

#Validate PartyInfo From/To initiator and responder roles. This property helps maintaining backwards compatibility. It is recommended to be enabled. By default enabled.
domibus.partyinfo.roles.validation.enabled=true

#Validate the qualified name of the Mpc in the received UserMessage on MSH endpoint matches the qualified name of the Mpc configured on the pMode leg configuration
domibus.pmode.legconfiguration.mpc.validation.enabled=true

#Accepted Format for action value in the PMode (Default value: ^[^=]*$: all characters but '=')
domibus.pmode.validation.action.pattern=^[^=]*$

#Accepted Format for service value in the PMode (Default value: ^[^=]*$: all characters but '=')
domibus.pmode.validation.service.value.pattern=^[^=]*$

#Accepted Format for service type in the PMode (Default value: ^[^=]*$: all characters but '=')
domibus.pmode.validation.service.type.pattern=^[^=]*$

# ---------------------------------- Various -----------------------------------

#The factory for creating SchemaFactory objects
domibus.javax.xml.validation.SchemaFactory=com.sun.org.apache.xerces.internal.jaxp.validation.XMLSchemaFactory

#The factory for creating SOAPMessage objects
messageFactoryClass=com.sun.xml.messaging.saaj.soap.ver1_2.SOAPMessageFactory1_2Impl

#If disabled, Domibus will not notify the plugins when the state of the User Message changes. Defaults to true.
domibus.plugin.notification.active=true

#If disabled, Domibus will not save the non repudiation audit data. Defaults to true.
domibus.nonrepudiation.audit.active=true

#The list of mime-types that will not be compressed (in outgoing messages) even if compression is turned on for the given message.
compressionBlacklist=application/vnd.etsi.asic-s+zip,image/jpeg

#Whether to delete the message payload on send failure. Defaults to false (the administrator can put the message back in the send queue).
domibus.sendMessage.failure.delete.payload=false

#Whether to delete the message payload on send success. Defaults to true (preserves backwards compatibility).
domibus.sendMessage.success.delete.payload=true

#If disabled, Domibus will not save the message attempt details when there is a failure sending a message. Defaults to true.
domibus.sendMessage.attempt.audit.active=true

#Should unrecoverable errors be retried or not
domibus.dispatch.ebms.error.unrecoverable.retry=true

#Number of threads used to parallelize the dispatching of messages to the plugins.
domibus.internal.queue.concurency=3-10

#Characters which are known to be hazardous are not accepted in user input : ',�,(,),{,},[,],;,,+,=,,%,&,*,#.< .>,/,\
domibus.userInput.blackList='\u0022(){}[];,+=%&*#<>/\\

#characters that are accepted in user input
domibus.userInput.whiteList=^[\\w\\-\\.: @]*$

#The maximum length accepted for a property value, in bytes. Defaults to 10000.
domibus.property.length.max=10000

#Enables the validation of Domibus properties values (defaults to true)
domibus.property.validation.enabled=true

#The minimum interval of time after which a new backup file is created, in hours. Defaults to 24. 0 for creating a backup file on every change.
domibus.property.backup.period.min=24

#The maximum number of backup files to keep. Defaults to 10. 0 for keeping all of them.
domibus.property.backup.history.max=10

#disables or enables propagation of exceptions on rest controllers
domibus.exceptions.rest.enable=true

#Prints the AS4 payload in the logs while org.apache.cxf is set to at least INFO in logback.xml. Defaults to false.
domibus.logging.payload.print=false

#Prints the AS4 metadata in the logs when org.apache.cxf is set to at least INFO in logback.xml. Defaults to true.
domibus.logging.metadata.print=true

#prints the raw XML response in the logs in case of EBMS3 error on receiver/sender side (if eu.domibus is put at least on ERROR)
domibus.logging.ebms3.error.print=true

#The size limit at which messages are truncated in the logs when org.apache.cxf is set to at least INFO in logback.xml
# Number between 0 and 1000000000 bytes
# Defaults to limit (18000 bytes)
domibus.logging.cxf.limit=18000

#Prints the details of the remote receiver certificate used to encrypt the message when sending or the details of the
#remote sender certificate used to verify the trust of the message when receiving. Defaults to false.
domibus.logging.remote.certificates.print=false

#Prints the details of the local sender certificate corresponding to its private key being used to sign the message
#when sending or the details of the local receiver certificate corresponding to its private key when decrypting the
#message when receiving. Please note, when enabling this property, there is an extra delay introduced needed to load
#the certificate corresponding to the private key. Defaults to false.
domibus.logging.local.certificates.print=false

#Disables offloading the SSL connection to another application - e.g. SSL Forward Proxy - (defaults to false)
domibus.connection.cxf.ssl.offload.enable=false

#The maximum file size in bytes that can be uploaded through REST ( pMode, trustStore). The default is 50MB.
domibus.file.upload.maxSize=52428800

#How long(in seconds) HSTS should last in the browser's cache(default one year)
domibus.httpSecurity.httpStrictTransportSecurity.maxAge=31536000

#Cron expression that specifies the frequency of dispatching messages stuck in SEND_ENQUEUED and WAITING_FOR_RETRY
domibus.messages.stuck.cron=0 0 0/3 * * ?

#The strategy adds these minutes to the interval used to search back for messages in SEND_ENQUEUED status to avoid
#unsent messages will be considered for being dispatched (irrespective if they are already currently being dispatched
# or not) - must be avoided; a value of at least 60 (minutes) is recommended.
domibus.messages.stuck.ignore.recent.minutes=360

# ---------------------------------- Password Policy -----------------------------------

#Password minimum complexity rules (empty to disable password complexity enforcement)
domibus.passwordPolicy.pattern=^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[~`!@#$%^&+=\\-_<>.,?:;*/()|\\[\\]{}'"\\\\]).{16,32}$

#The error message shown to the user in case the password does not follow the regex put in the domibus.passwordPolicy.pattern property
domibus.passwordPolicy.validationMessage=Minimum length: 16 characters;Maximum length: 32 characters;At least one letter in lowercase;At least one letter in uppercase;At least one digit;At least one special character

#Password expiration policy in days (0 to disable)
domibus.passwordPolicy.expiration=90

#Default password expiration policy in days (0 to disable)
domibus.passwordPolicy.defaultPasswordExpiration=15

#Password expiration policy: how many days before expiration should the system warn users at login
domibus.passwordPolicy.warning.beforeExpiration=15

#Password reuse policy: do not reuse any of the last N passwords (0 to disable)
domibus.passwordPolicy.dontReuseLast=5

#Default password validation policy enabled/disabled (by default is enabled)
domibus.passwordPolicy.checkDefaultPassword=true

#Default user creation policy enabled/disabled (by default is enabled)
domibus.passwordPolicy.defaultUser.create=true

#Default user password generation policy enabled/disabled (by default is enabled)
domibus.passwordPolicy.defaultUser.autogeneratePassword=true

#Cron expression that specifies the frequency of the password expiration check
domibus.passwordPolicies.check.cron=0 0 0/1 * * ?

# ---------------------------------- Plugin Users Password Policy -----------------------------------

#Password minimum complexity rules (empty to disable password complexity enforcement)
domibus.plugin.passwordPolicy.pattern=(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[~`!@#$%^&+=\\-_<>.,?:;*/()|\\[\\]{}'"\\\\]).{16,32}$

#The error message shown to the user in case the password does not follow the regex put in the domibus.plugin.passwordPolicy.pattern property
domibus.plugin.passwordPolicy.validationMessage=Minimum length: 16 characters;Maximum length: 32 characters;At least one letter in lowercase;At least one letter in uppercase;At least one digit;At least one special character

#Password expiration policy in days (0 to disable)
domibus.plugin.passwordPolicy.expiration=90

#Default password expiration policy in days (0 to disable)
domibus.plugin.passwordPolicy.defaultPasswordExpiration=1

#Password reuse policy: do not reuse any of the last N passwords (0 to disable)
domibus.plugin.passwordPolicy.dontReuseLast=5

#Cron expression that specifies the frequency of the password expiration check
domibus.plugin_passwordPolicies.check.cron=0 0 0/1 * * ?

#Accepted Format for xsd:datetime for AS4 communication
domibus.datetime.pattern.onreceiving=yyyy-MM-dd'T'HH:mm:ss[.SSSSSSSSS][.SSSSSS][.SSS][z]

#Format of xsd:datetime used for AS4Receipt
domibus.datetime.pattern.onsending=yyyy-MM-dd'T'HH:mm:ss.SSS'Z'

# ---------------------------------- Alert management:Password policy  -----------------

#Enable/disable the imminent password expiration alert
domibus.alert.password.imminent_expiration.active=true

#Number of days before expiration as for how long before expiration the system should send alerts.
domibus.alert.password.imminent_expiration.delay_days=15

#Frequency in days between alerts.
domibus.alert.password.imminent_expiration.frequency_days=3

#Password imminent expiration alert level.
domibus.alert.password.imminent_expiration.level=LOW

#Password imminent expiration mail subject.
domibus.alert.password.imminent_expiration.mail.subject=Password imminent expiration

#Enable/disable the imminent password expiration alert
domibus.alert.password.expired.active=true

#Number of days after expiration as for how long the system should send alerts.
domibus.alert.password.expired.delay_days=30

#Frequency in days between alerts.
domibus.alert.password.expired.frequency_days=5

#Password expiration alert level.
domibus.alert.password.expired.level=LOW

#Password expiration mail subject.
domibus.alert.password.expired.mail.subject=Password expired

# ---------------------------------- Alert management: Plugin Password policy  -----------------

#Enable/disable the imminent password expiration alert
domibus.alert.plugin_password.imminent_expiration.active=true

#Number of days before expiration as for how long before expiration the system should send alerts.
domibus.alert.plugin_password.imminent_expiration.delay_days=15

#Frequency in days between alerts.
domibus.alert.plugin_password.imminent_expiration.frequency_days=3

#Password imminent expiration alert level.
domibus.alert.plugin_password.imminent_expiration.level=LOW

#Password imminent expiration mail subject.
domibus.alert.plugin_password.imminent_expiration.mail.subject=Password imminent expiration

#Enable/disable the imminent password expiration alert
domibus.alert.plugin_password.expired.active=true

#Number of days after expiration as for how long the system should send alerts.
domibus.alert.plugin_password.expired.delay_days=30

#Frequency in days between alerts.
domibus.alert.plugin_password.expired.frequency_days=5

#Password expiration alert level.
domibus.alert.plugin_password.expired.level=LOW

#Password expiration mail subject.
domibus.alert.plugin_password.expired.mail.subject=Password expired

# ------------------------------- Domibus instance/environment name ------------------
domibus.instance.name = Domibus

# ---------------------------------- Alert management:Authentication module for Plugin users-----------------

#Enable/disable the login failure alert of the authentication module.
domibus.alert.plugin.user.login_failure.active=true

#Alert level for login failure.
domibus.alert.plugin.user.login_failure.level=LOW

#Login failure mail subject.
domibus.alert.plugin.user.login_failure.mail.subject=Login failure

#Enable/disable the account disable alert of the authentication module.
domibus.alert.plugin.user.account_disabled.active=true

#Alert level for account disabled. Used in the email to be sent. Values: {LOW, MEDIUM, HIGH}
domibus.alert.plugin.user.account_disabled.level=HIGH

#When should the account disabled alert be triggered.
# 2 possible values:
# AT_LOGON: An alert will be triggered each time a user tries to login to a disabled account.
# WHEN_BLOCKED: An alert will be triggered once when the account got disabled.
domibus.alert.plugin.user.account_disabled.moment=WHEN_BLOCKED

#Account disabled mail subject.
domibus.alert.plugin.user.account_disabled.subject=Account disabled

#Enable/disable the account enabled alert of the authentication module.
domibus.alert.plugin.user.account_enabled.active=false

#Alert level for account enabled. Used in the email to be sent. Values: {LOW, MEDIUM, HIGH}
domibus.alert.plugin.user.account_enabled.level=MEDIUM

#Account enabled mail subject.
domibus.alert.plugin.user.account_enabled.subject=Account enabled

# ---------------------------------- Metrics -----------------

#Enable jmx reporter for dropwizard metrics. The following warning:
#We do not recommend that you try to gather metrics from your production environment.JMX's RPC API is fragile.
#For development purposes and browsing, though, it can be very useful.
domibus.metrics.jmx.reporter.enable=false

#Enable SLF4J reporter for dropwizard metrics.
domibus.metrics.slf4j.reporter.enable=false

#The time unit used to configure the frequency of writing statistics into the statistic.log file.
#Possible values are:SECONDS, MINUTES, HOURS
domibus.metrics.slf4j.reporter.period.time.unit=MINUTES

#The number of period of the previously time unit used to configure the frequency of writing statistics into the statistic.log file.
#For example, the default configuration will write statistics with the file every 1 MINUTE.
domibus.metrics.slf4j.reporter.period.number=1

#Activate drop wizard memory metrics
domibus.metrics.monitor.memory=false

#Activate drop wizard gc metrics
domibus.metrics.monitor.gc=false

#Activate drop wizard cached threads metrics
domibus.metrics.monitor.cached.threads=false

#Activate drop wizard JMS Queues metrics
domibus.metrics.monitor.jms.queues=false

# how long (in seconds) the JMS count will be cached
# defaults to 10
domibus.metrics.monitor.jms.queues.refresh.period=10

# show counts only for DLQ queue
domibus.metrics.monitor.jms.queues.show.dlq.only=true

# ------------------------------- SplitAndJoin ---------------------------------------

#Specify concurrency limits via a "lower-upper" String, e.g. "5-10", or a simple upper limit String, e.g. "10" (the lower limit will be 1 in this case)
#when sending the SourceMessage receipt(Split and Join) to other Access Points
domibus.dispatcher.splitAndJoin.concurrency=1

#The threshold value in MB to switch from synchronous to asynchronous saving of outgoing SourceMessage payloads
domibus.dispatcher.splitAndJoin.payloads.schedule.threshold=1000

#Cron expression that specifies the frequency of the checking if the joinInterval has expired
domibus.splitAndJoin.receive.expiration.cron=0 0/5 * * * ?

# --------------------------- Connection Monitoring ----------------------------------

#Specifies the parties for which to monitor the connection (comma separated list)
domibus.monitoring.connection.party.enabled=

#Specifies the parties for which to delete the old test messages (comma separated list)
domibus.monitoring.connection.party.history.delete=ALL

#Cron expression that specifies the frequency of test messages sent to monitor the C2-C3 connections
domibus.monitoring.connection.cron=0 0 0/2 ? * * *

#Cron expression that specifies the frequency of test messages sent to itself (e.g. C2-C2 connections)
domibus.monitoring.connection.self.cron=0 0 0/1 ? * * *

#Cron expression that specifies the frequency of deleting test message history sent to gateway party
domibus.monitoring.connection.messages.received.history.delete.cron=0 0 0/1 ? * * *

# --------------------------------------------Error Logs-------------------------------

#Cron configuration for cleaning error logs without message ids.
domibus.errorlog.cleaner.cron=0 0 0/1 * * ?

#Cron job will delete error logs without message ids older than this property days
domibus.errorlog.cleaner.older.days=100

#how maximum error logs will be deleted for each job run
domibus.errorlog.cleaner.batch.size=5000

# --------------------------------------------EArchiving-------------------------------
#Domibus allows for e-archiving if activated
domibus.earchive.active=false

#Allows to create empty export batches if no messages are found. If false, no batch nor files created when no messages found.
domibus.earchive.export.empty=false

#Specify concurrency limits via a "lower-upper" String, e.g. "5-10", or a simple upper limit String, e.g. "10" (the lower limit will be 1 in this case)
#for the eArchiving queue
domibus.earchive.queue.concurrency=1-1

#Specify concurrency limits via a "lower-upper" String, e.g. "5-10", or a simple upper limit String, e.g. "10" (the lower limit will be 1 in this case)
#when notify batches updates to other EArchive client
domibus.earchive.notification.queue.concurrency=1-1

#Specify concurrency limits via a "lower-upper" String, e.g. "5-10", or a simple upper limit String, e.g. "10" (the lower limit will be 1 in this case)
#when error in notifying batches updates to other EArchive client
domibus.earchive.notification.dlq.concurrency=1-1

#Cron configuration for executing the eArchiving continuous process.
domibus.earchive.cron=0 0 0/1 * * ?

#Cron configuration for executing the eArchiving sanity process.
domibus.earchive.sanitizer.cron=0 0 0/1 * * ?

#The creation date of the last UserMessage processed by the earchiving continuous batch minus the ['messageCheck.delay' hour] will be latest userMessage taken for the sanitizer
domibus.earchive.sanitizer.messagesCheck.delay.hours=24

#Cron configuration for executing the eArchiving cleanup process.
domibus.earchive.retention.cron=0 0 0/2 * * ?

#maximum messages to be archived for one batch
domibus.earchive.batch.size=5000

#maximum payload size of messages to be archived for one batch(in Mb); 0 to disable
domibus.earchive.batch.size.payload=0

#maximum earchive batches to be created during one job
domibus.earchive.batch.max=10

#Timeout used to retrieve the messages in minutes. Defaults to 0. Defaults to 0.
# WARNING: this value is rounded to the previous whole hour to limit the messages search scope
# (ex: runtime = 15h12 | if retry.timeout=5  -> latest time for a message to be taken into account: 15h00 and earlier
#                      | if retry.timeout=30 -> latest time for a message to be taken into account: 14h00 and earlier)
#-1 disables this functionality and retrieve the timeout with the loaded PMode
domibus.earchive.batch.retry.timeout=0

# For methods: History Of Exports and enqueued batches, also return message list as part of batches objects.
# Note: in case of large batch size returning message list in all of the batches in a list will slow down the response time of the services.
domibus.earchive.rest.messages.return=false

#Timeout used when notifying the e-archiving client
domibus.earchive.notification.timeout=5000

#Specify whether to use a proxy when notifying the e-archiving client
domibus.earchive.notification.useProxy=false

#If a batch is not archived during this time, it is considered as expired
domibus.earchive.retention.days=30

#Maximum number of earchive batches to delete at a time
domibus.earchive.retention.delete.max=5000

#If physically delete archived and/or expired batches from the corresponding tables
domibus.earchive.retention.delete.db=true

#An alert is sent if the start date of the continuous job was not updated between now and now - allowed_window (in hours)
domibus.earchive.start_date.stopped.allowed_hours=24

#Enable/disable the Earchive non final message alert.
domibus.alert.earchive.messages_non_final.active=true

#Alert level for Earchive non final message.
domibus.alert.earchive.messages_non_final.level=HIGH

#Earchive non final message mail subject.
domibus.alert.earchive.messages_non_final.mail.subject=Earchive: message not in final state

#Enable/disable the Earchive start date stopped alert.
domibus.alert.earchive.start_date_stopped.active=true

#Alert level for Earchive start date stopped.
domibus.alert.earchive.start_date_stopped.level=HIGH

#Earchive start date stopped mail subject.
domibus.alert.earchive.start_date_stopped.mail.subject=Earchive: continuous job start date stopped

#Enable if e-archiving client needs to receive notifications with additional details like message start date and end date
domibus.earchive.notification.details.enabled=false

#Enable/disable the Earchive message export failed alert.
domibus.alert.earchive.export.failed.active=true

#Alert level for Earchive message export failed alert.
domibus.alert.earchive.export.failed.level=HIGH

#Earchive message export failed alert mail subject.
domibus.alert.earchive.export.failed.mail.subject=Earchive: sanitizer export message failed

#Cron configuration for executing the eArchiving process needed to reexport stuck messages.
domibus.earchive.stuck.cron=0 0 0/1 * * ?

#The strategy adds these minutes to the interval used to search back for batches stuck in STARTED statuses to avoid
#picking up batches that have been just created. Only positive values allowed; a value of at least 360 (minutes) is
#recommended.
domibus.earchive.stuck.ignore.recent.minutes=360

# --------------------------------------------Quartz-------------------------------
#Specifies the amount of time, in milliseconds that used to check if any quartz triggers are blocked. Default value is 10 minutes.
domibus.quartz.trigger.blocked.duration=600000

# --------------------------------------------Distributed Cache -------------------------------
#The distributed cache is only used when Domibus runs in a cluster eg domibus.deployment.clustered=true

#Maximum used heap size in megabytes
domibus.cache.distributed.size=5

#The maximum number of seconds for each entry to stay in the cache. Entries that are older than timeToLiveSeconds will be automatically evicted from the cache.
#Updates on the entry will change the eviction time. Any integer between 0 and Integer.MAX_VALUE. 0 means infinite. Default is 1h.
domibus.cache.distributed.ttl=3600

#Maximum number of seconds for each entry to stay idle in the cache. Entries that are idle (not touched) for more than max idle seconds will get automatically evicted from the cache.
#Entry is touched if get(), getAll(), put() or containsKey() is called. Any integer between 0 and Integer.MAX_VALUE. 0 means infinite. Default is 3600.
#The time precision is limited by 1 second. The MaxIdle that less than 1 second can lead to unexpected behaviour.
domibus.cache.distributed.idle.max=3600

#The near cache default size for the distributed cache
domibus.cache.distributed.nearcache.size=5000

#The maximum number of seconds for each entry to stay in the near cache
domibus.cache.distributed.nearcache.ttl=3600

#Set the maximum number of seconds each entry can stay in the Near Cache as untouched (not-read).
#Entries that are not read (touched) more than domibus.cache.distributed.nearcache.idle.max value will get removed from the Near Cache.
domibus.cache.distributed.nearcache.idle.max=3600

#Sets the port the distributed cache member will try to bind on.
#A valid port value is between 0 and 65535. A port number of 0 will let the system pick up an ephemeral port.
domibus.cache.distributed.port=6701

#Sets if a distributed cache member is allowed to find a free port by incrementing the port number when it encounters an occupied port.
#If you explicitly want to control the port a distributed cache member is going to use, set domibus.cache.distributed.port.autoincrement to false. In this case, the distributed cache member is going to try the port
#and if the port is not free, the member will not start and throw an exception.
#If this value is set to true, the distributed cache will start at the port specified and will try until it finds a free port, or until it runs out of ports to try
domibus.cache.distributed.port.autoincrement=true

#The maximum number of ports allowed to use in case autoincrement is set to true
domibus.cache.distributed.port.count=5

#Sets the well known members of the distributed cache. Can be a comma separated string, eg '10.11.12.1,10.11.12.2' which indicates multiple members are going to be added.
domibus.cache.distributed.members=127.0.0.1

# ---------------------------------- EhCache ----------------------------------

#Disk cache location, used in the ehCache configuration by all caches with a disk storage tier
domibus.cache.location=${java.io.tmpdir}/cache
